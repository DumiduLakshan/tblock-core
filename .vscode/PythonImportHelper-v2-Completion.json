[
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "hmac",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac",
        "description": "hmac",
        "detail": "hmac",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Form",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTMLResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "RedirectResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "BanStore",
        "importPath": "ban_store",
        "description": "ban_store",
        "isExtraImport": true,
        "detail": "ban_store",
        "documentation": {}
    },
    {
        "label": "BanStore",
        "importPath": "ban_store",
        "description": "ban_store",
        "isExtraImport": true,
        "detail": "ban_store",
        "documentation": {}
    },
    {
        "label": "Settings",
        "importPath": "torrent_watch",
        "description": "torrent_watch",
        "isExtraImport": true,
        "detail": "torrent_watch",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "importPath": "torrent_watch",
        "description": "torrent_watch",
        "isExtraImport": true,
        "detail": "torrent_watch",
        "documentation": {}
    },
    {
        "label": "XuiClient",
        "importPath": "torrent_watch",
        "description": "torrent_watch",
        "isExtraImport": true,
        "detail": "torrent_watch",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "ipaddress",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ipaddress",
        "description": "ipaddress",
        "detail": "ipaddress",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "getpass",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getpass",
        "description": "getpass",
        "detail": "getpass",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "BanStore",
        "kind": 6,
        "importPath": "pTblock.ban_store",
        "description": "pTblock.ban_store",
        "peekOfCode": "class BanStore:\n    def __init__(self, path: Path):\n        self.path = path\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n        self._init_db()\n    def _init_db(self) -> None:\n        conn = sqlite3.connect(self.path)\n        cur = conn.cursor()\n        cur.execute(\n            \"\"\"",
        "detail": "pTblock.ban_store",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def init():\n    global SETTINGS, STORE, XUI, SECRET\n    load_dotenv()\n    SETTINGS = load_settings()\n    STORE = BanStore(SETTINGS.ban_db)\n    XUI = XuiClient(SETTINGS)\n    SECRET = hashlib.sha256(f\"{SETTINGS.username}{SETTINGS.password}\".encode()).hexdigest()\ndef sign_cookie(username: str) -> str:\n    msg = username.encode()\n    sig = hmac.new(SECRET.encode(), msg, hashlib.sha256).hexdigest()",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "sign_cookie",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def sign_cookie(username: str) -> str:\n    msg = username.encode()\n    sig = hmac.new(SECRET.encode(), msg, hashlib.sha256).hexdigest()\n    return f\"{username}:{sig}\"\ndef verify_cookie(token: str) -> bool:\n    if \":\" not in token:\n        return False\n    user, sig = token.split(\":\", 1)\n    expected = hmac.new(SECRET.encode(), user.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(sig, expected) and user == SETTINGS.username",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "verify_cookie",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def verify_cookie(token: str) -> bool:\n    if \":\" not in token:\n        return False\n    user, sig = token.split(\":\", 1)\n    expected = hmac.new(SECRET.encode(), user.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(sig, expected) and user == SETTINGS.username\ndef require_auth(request: Request):\n    if not SETTINGS:\n        raise HTTPException(status_code=500, detail=\"Not ready\")\n    token = request.cookies.get(\"tblock_auth\", \"\")",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "require_auth",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def require_auth(request: Request):\n    if not SETTINGS:\n        raise HTTPException(status_code=500, detail=\"Not ready\")\n    token = request.cookies.get(\"tblock_auth\", \"\")\n    if not token or not verify_cookie(token):\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n@app.get(\"/login\", response_class=HTMLResponse)\ndef login_page():\n    html = \"\"\"\n    <html><head><title>Tblock Admin</title>",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "login_page",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def login_page():\n    html = \"\"\"\n    <html><head><title>Tblock Admin</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap\" rel=\"stylesheet\">\n    <style>\n    body { margin:0; display:flex; align-items:center; justify-content:center; min-height:100vh; background:#f2f4ff;\n           font-family:'Poppins',sans-serif; }",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "do_login",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def do_login(username: str = Form(...), password: str = Form(...)):\n    if not SETTINGS:\n        raise HTTPException(status_code=500, detail=\"Not ready\")\n    if username == SETTINGS.username and password == SETTINGS.password:\n        token = sign_cookie(username)\n        resp = RedirectResponse(url=\"/\", status_code=302)\n        resp.set_cookie(\"tblock_auth\", token, httponly=True, max_age=60 * 60 * 12)\n        return resp\n    return HTMLResponse(\"<html><body>Invalid credentials.<br><a href='/login'>Try again</a></body></html>\", status_code=401)\n@app.get(\"/\", response_class=HTMLResponse)",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def home(q: str = \"\", request: Request = None):\n    try:\n        require_auth(request)\n    except Exception:\n        return RedirectResponse(url=\"/login\", status_code=302)\n    bans = STORE.list(q) if STORE else []\n    stats = STORE.stats() if STORE else {\"total\": 0}\n    rows = \"\".join(\n        f\"<tr onclick=\\\"showDetails('{b['email']}')\\\" style='cursor:pointer;'>\"\n        f\"<td>{b['email']}</td><td>{b['ip']}</td><td>{b['domain']}</td><td>{b['created_at']}</td>\"",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "unban",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def unban(email: str = Form(...), request: Request = None):\n    try:\n        require_auth(request)\n    except Exception:\n        return RedirectResponse(url=\"/login\", status_code=302)\n    if not XUI or not STORE:\n        raise HTTPException(status_code=500, detail=\"Not ready\")\n    client = XUI.get_client(email)\n    if not client:\n        STORE.mark_unbanned(email)",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "client_details",
        "kind": 2,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "def client_details(email: str, request: Request = None):\n    try:\n        require_auth(request)\n    except Exception:\n        return JSONResponse({\"detail\": \"Unauthorized\"}, status_code=401)\n    try:\n        client = XUI.get_client(email)\n    except Exception as exc:\n        return JSONResponse({\"detail\": str(exc)}, status_code=500)\n    if not client:",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent\nif str(BASE_DIR) not in sys.path:\n    sys.path.insert(0, str(BASE_DIR))\nfrom ban_store import BanStore\nfrom torrent_watch import Settings, load_settings, XuiClient\napp = FastAPI(title=\"Tblock Admin\")\nSETTINGS: Optional[Settings] = None\nSTORE: Optional[BanStore] = None\nXUI: Optional[XuiClient] = None\nSECRET: str = secrets.token_hex(16)",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "pTblock.panel_app",
        "description": "pTblock.panel_app",
        "peekOfCode": "app = FastAPI(title=\"Tblock Admin\")\nSETTINGS: Optional[Settings] = None\nSTORE: Optional[BanStore] = None\nXUI: Optional[XuiClient] = None\nSECRET: str = secrets.token_hex(16)\ndef init():\n    global SETTINGS, STORE, XUI, SECRET\n    load_dotenv()\n    SETTINGS = load_settings()\n    STORE = BanStore(SETTINGS.ban_db)",
        "detail": "pTblock.panel_app",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class Settings:\n    log_path: Path\n    output_file: Path\n    panel_scheme: str\n    panel_host: str\n    panel_port: int\n    panel_base_path: str\n    username: str\n    password: str\n    two_factor: Optional[str]",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "XuiClient",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class XuiClient:\n    def __init__(self, settings: Settings):\n        self.settings = settings\n        self.session = requests.Session()\n        self.login()\n    def login(self) -> None:\n        payload: Dict[str, Any] = {\n            \"username\": self.settings.username,\n            \"password\": self.settings.password,\n        }",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "BanLog",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class BanLog:\n    def __init__(self, path: Path):\n        self.path = path\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n        self.entries = self._load()\n    def _load(self) -> list[Dict[str, Any]]:\n        if not self.path.exists():\n            return []\n        try:\n            content = json.loads(self.path.read_text())",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "WebhookNotifier",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class WebhookNotifier:\n    def __init__(self, url: Optional[str], token: Optional[str]):\n        self.url = url\n        self.token = token\n    def notify(self, payload: Dict[str, Any]) -> None:\n        if not self.url:\n            return\n        headers = {\"Content-Type\": \"application/json\"}\n        if self.token:\n            headers[\"X-Webhook-Token\"] = self.token",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "WhatsAppNotifier",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class WhatsAppNotifier:\n    def __init__(self, enabled: bool, api_key: Optional[str], channel: Optional[str]):\n        self.enabled = enabled and bool(api_key) and bool(channel)\n        self.api_key = api_key\n        self.channel = channel\n    def send_ban(self, email: str, domain: str, hours: int) -> None:\n        if not self.enabled:\n            return\n        payload = {\n            \"to\": self.channel,",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "TorrentWatcher",
        "kind": 6,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "class TorrentWatcher:\n    def __init__(self, settings: Settings):\n        self.settings = settings\n        self.xui = XuiClient(settings)\n        self.log = BanLog(settings.log_file)\n        self.ban_store = BanStore(settings.ban_db)\n        self.notifier = WebhookNotifier(settings.webhook_url, settings.webhook_token)\n        self.wa = WhatsAppNotifier(settings.wa_enabled, settings.wa_api_key, settings.wa_channel)\n        self.output_file = settings.output_file\n        self.output_file.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "load_settings",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def load_settings(env_path: Optional[Path] = None) -> Settings:\n    if env_path:\n        load_dotenv(env_path)\n    else:\n        load_dotenv()\n    def must_get(key: str) -> str:\n        val = os.getenv(key)\n        if not val:\n            raise RuntimeError(f\"Missing required environment variable {key}\")\n        return val",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "follow_file",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def follow_file(path: Path) -> Iterable[str]:\n    with path.open(\"r\", encoding=\"utf-8\", errors=\"ignore\") as fh:\n        fh.seek(0, os.SEEK_END)\n        while True:\n            line = fh.readline()\n            if not line:\n                yield \"\"\n            else:\n                yield line\ndef parse_line(line: str) -> Tuple[Optional[str], Optional[str], str, Optional[str], bool, Optional[int]]:",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def parse_line(line: str) -> Tuple[Optional[str], Optional[str], str, Optional[str], bool, Optional[int]]:\n    parts = line.strip().split()\n    if len(parts) < 6:\n        return None, None, \"\", None, False, None\n    timestamp = \" \".join(parts[:2])\n    ip_section = next((p for p in parts if p.startswith(\"from\")), None)\n    email_idx = next((i for i, p in enumerate(parts) if p == \"email:\"), None)\n    ip = None\n    if ip_section:\n        idx = parts.index(ip_section)",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def setup_logging() -> None:\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setFormatter(logging.Formatter(\"[%(asctime)s] %(levelname)s %(message)s\"))\n    LOG.addHandler(handler)\n    LOG.setLevel(logging.WARNING)\nclass TorrentWatcher:\n    def __init__(self, settings: Settings):\n        self.settings = settings\n        self.xui = XuiClient(settings)\n        self.log = BanLog(settings.log_file)",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Torrent watcher daemon\")\n    parser.add_argument(\n        \"--env-file\",\n        help=\"Path to .env file (defaults to .env in repo root)\",\n    )\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Verbose logging\")\n    return parser.parse_args()\ndef main() -> int:\n    setup_logging()",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "def main() -> int:\n    setup_logging()\n    args = parse_args()\n    env_path = Path(args.env_file) if args.env_file else None\n    settings = load_settings(env_path)\n    if args.debug:\n        LOG.setLevel(logging.DEBUG)\n    watcher = TorrentWatcher(settings)\n    LOG.info(\"Service configured. Offender file: %s | Ban log: %s\", settings.output_file, settings.log_file)\n    watcher.run()",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent\nif str(BASE_DIR) not in sys.path:\n    sys.path.insert(0, str(BASE_DIR))\nfrom ban_store import BanStore\nLOG = logging.getLogger(\"torrent_watch\")\nBLOCK_MARKERS = (\"blocked\", \">> block\", \"[block\")\nDEFAULT_OUTPUT = \"data/torrent-offenders.txt\"\nDEFAULT_LOG_DB = \"data/ban_log.json\"\n@dataclass\nclass Settings:",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "LOG = logging.getLogger(\"torrent_watch\")\nBLOCK_MARKERS = (\"blocked\", \">> block\", \"[block\")\nDEFAULT_OUTPUT = \"data/torrent-offenders.txt\"\nDEFAULT_LOG_DB = \"data/ban_log.json\"\n@dataclass\nclass Settings:\n    log_path: Path\n    output_file: Path\n    panel_scheme: str\n    panel_host: str",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "BLOCK_MARKERS",
        "kind": 5,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "BLOCK_MARKERS = (\"blocked\", \">> block\", \"[block\")\nDEFAULT_OUTPUT = \"data/torrent-offenders.txt\"\nDEFAULT_LOG_DB = \"data/ban_log.json\"\n@dataclass\nclass Settings:\n    log_path: Path\n    output_file: Path\n    panel_scheme: str\n    panel_host: str\n    panel_port: int",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OUTPUT",
        "kind": 5,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "DEFAULT_OUTPUT = \"data/torrent-offenders.txt\"\nDEFAULT_LOG_DB = \"data/ban_log.json\"\n@dataclass\nclass Settings:\n    log_path: Path\n    output_file: Path\n    panel_scheme: str\n    panel_host: str\n    panel_port: int\n    panel_base_path: str",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOG_DB",
        "kind": 5,
        "importPath": "pTblock.torrent_watch",
        "description": "pTblock.torrent_watch",
        "peekOfCode": "DEFAULT_LOG_DB = \"data/ban_log.json\"\n@dataclass\nclass Settings:\n    log_path: Path\n    output_file: Path\n    panel_scheme: str\n    panel_host: str\n    panel_port: int\n    panel_base_path: str\n    username: str",
        "detail": "pTblock.torrent_watch",
        "documentation": {}
    },
    {
        "label": "fail",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           \n| | | |   | |          | |     / _| |    (_)         | |      | | |          \n| |_| |__ | | ___   ___| | __ | |_| | __  _ _ __  ___| |_ __ _| | | ___ _ __ \n| __| '_ \\| |/ _ \\ / __| |/ / |  _| |/ / | | '_ \\/ __| __/ _` | | |/ _ \\ '__|\n| |_| |_) | | (_) | (__|   < _| | |   <  | | | | \\__ \\ || (_| | | |  __/ |   ",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "banner",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           \n| | | |   | |          | |     / _| |    (_)         | |      | | |          \n| |_| |__ | | ___   ___| | __ | |_| | __  _ _ __  ___| |_ __ _| | | ___ _ __ \n| __| '_ \\| |/ _ \\ / __| |/ / |  _| |/ / | | '_ \\/ __| __/ _` | | |/ _ \\ '__|\n| |_| |_) | | (_) | (__|   < _| | |   <  | | | | \\__ \\ || (_| | | |  __/ |   \n \\__|_.__/|_|\\___/ \\___|_|\\_(_)_| |_|\\_\\ |_|_| |_|___/\\__\\__,_|_|_|\\___|_|   \n    \"\"\"\n    print(f\"{CYAN}{art}{RESET}\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "get_server_ip",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def get_server_ip() -> str:\n    try:\n        result = subprocess.run(\n            [\"ip\", \"route\", \"get\", \"1.1.1.1\"],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n        parts = result.stdout.split()\n        for idx, token in enumerate(parts):",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "check_ubuntu",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def check_ubuntu():\n    if platform.system().lower() != \"linux\":\n        fail(\"Only Linux is supported\")\n    try:\n        with open(\"/etc/os-release\", \"r\", encoding=\"utf-8\") as f:\n            data = f.read().lower()\n        if \"ubuntu\" not in data:\n            fail(\"Only Ubuntu is supported\")\n    except FileNotFoundError:\n        fail(\"Cannot detect OS; /etc/os-release missing\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "check_xui_installed",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def check_xui_installed():\n    if not XUI_DB_PATH.exists():\n        fail(\"3x-ui not detected. Install 3x-ui first.\")\ndef check_cert_present():\n    try:\n        conn = sqlite3.connect(XUI_DB_PATH)\n        cur = conn.cursor()\n        cur.execute(\"select key, value from settings where key in ('webCertFile','webKeyFile')\")\n        rows = cur.fetchall()\n        conn.close()",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "check_cert_present",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def check_cert_present():\n    try:\n        conn = sqlite3.connect(XUI_DB_PATH)\n        cur = conn.cursor()\n        cur.execute(\"select key, value from settings where key in ('webCertFile','webKeyFile')\")\n        rows = cur.fetchall()\n        conn.close()\n    except Exception as e:\n        fail(f\"Failed to read x-ui settings: {e}\")\n    settings = {k: v for k, v in rows}",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "ensure_venv",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def ensure_venv(base: Path) -> Path:\n    venv_path = base / \"venv\"\n    if not venv_path.exists():\n        try:\n            subprocess.check_call([sys.executable, \"-m\", \"venv\", str(venv_path)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        except subprocess.CalledProcessError as e:\n            print(\"[!] Creating virtualenv failed. Attempting to install python3-venv ...\")\n            installer = [\"apt-get\", \"install\", \"-y\", \"python3-venv\"]\n            if os.geteuid() != 0:\n                installer.insert(0, \"sudo\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "run_pip",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def run_pip(venv: Path, packages):\n    pip = venv / \"bin\" / \"pip\"\n    if not pip.exists():\n        py = venv / \"bin\" / \"python\"\n        try:\n            subprocess.check_call([str(py), \"-m\", \"ensurepip\", \"--upgrade\"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        except Exception:\n            fail(\"pip is missing in the virtualenv. Install python3-venv and python3-pip, then rerun.\")\n    if not pip.exists():\n        fail(\"pip is missing in the virtualenv. Install python3-venv and python3-pip, then rerun.\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "load_requests",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def load_requests(venv: Path):\n    major, minor = sys.version_info[:2]\n    site_packages = venv / \"lib\" / f\"python{major}.{minor}\" / \"site-packages\"\n    if site_packages.exists() and str(site_packages) not in sys.path:\n        sys.path.insert(0, str(site_packages))\n    try:\n        return import_module(\"requests\")\n    except ImportError as e:\n        fail(f\"requests not available even after install: {e}\")\ndef get_public_ip() -> str:",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "get_public_ip",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def get_public_ip() -> str:\n    try:\n        resp = REQUESTS.get(\"https://api.ipify.org?format=json\", timeout=8)\n        resp.raise_for_status()\n        return resp.json().get(\"ip\")\n    except Exception as e:\n        fail(f\"Could not determine public IP: {e}\")\ndef validate_with_backend(token: str, vps_ip: str, hostname: str | None = None):\n    if not VALIDATOR_URL:\n        fail(\"VALIDATOR_URL not set\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "validate_with_backend",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def validate_with_backend(token: str, vps_ip: str, hostname: str | None = None):\n    if not VALIDATOR_URL:\n        fail(\"VALIDATOR_URL not set\")\n    payload = {\"token\": token, \"vps_ip\": vps_ip, \"hostname\": hostname or \"\"}\n    try:\n        resp = REQUESTS.post(VALIDATOR_URL.rstrip(\"/\") + \"/validate\", data=json.dumps(payload), headers={\"Content-Type\": \"application/json\"}, timeout=10)\n        if resp.status_code >= 400:\n            msg = \"\"\n            if resp.headers.get(\"content-type\", \"\").startswith(\"application/json\"):\n                data = resp.json()",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "load_xui_config",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def load_xui_config():\n    try:\n        conn = sqlite3.connect(XUI_DB_PATH)\n        cur = conn.cursor()\n        cur.execute(\"select key, value from settings where key in ('webPort','webBasePath','webCertFile','webKeyFile','twoFactorToken')\")\n        settings_rows = cur.fetchall()\n        cur.execute(\"select username from users limit 1\")\n        user_row = cur.fetchone()\n        conn.close()\n    except Exception as e:",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "verify_wasender",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def verify_wasender(api_key: str) -> bool:\n    try:\n        resp = REQUESTS.get(\n            \"https://www.wasenderapi.com/api/whatsapp-sessions\",\n            headers={\"Authorization\": f\"Bearer {api_key}\"},\n            timeout=10,\n        )\n        data = resp.json()\n        if resp.status_code == 200 and isinstance(data, dict) and data.get(\"success\") and data.get(\"data\"):\n            return True",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "test_wasender_message",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def test_wasender_message(api_key: str, channel_id: str) -> Tuple[bool, str]:\n    try:\n        payload = {\"to\": channel_id, \"text\": \"tblock.fk test message\"}\n        resp = REQUESTS.post(\n            \"https://www.wasenderapi.com/api/send-message\",\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"Content-Type\": \"application/json\",\n            },\n            data=json.dumps(payload),",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "ensure_access_log",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def ensure_access_log(log_path: Path):\n    while True:\n        if log_path.exists():\n            print(f\"{GREEN}âœ“ Access log detected{RESET}\")\n            return\n        print(f\"{YELLOW}Access log not found at {log_path}{RESET}\")\n        print(\"Enable logging in 3x-ui (Panel -> Settings -> Logs) and ensure access log is on.\")\n        ans = input(f\"{CYAN}Have you enabled the log? (y/n): {RESET}\").strip().lower()\n        if ans == \"y\":\n            continue",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "install_requirements",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def install_requirements(venv: Path, base: Path):\n    req = base / \"requirements.txt\"\n    if not req.exists():\n        req.write_text(\"requests\\npython-dotenv\\n\", encoding=\"utf-8\")\n    pip = venv / \"bin\" / \"pip\"\n    subprocess.check_call([str(pip), \"install\", \"-r\", str(req)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\ndef write_service(base: Path, venv: Path, env_path: Path):\n    service = textwrap.dedent(\n        f\"\"\"\n        [Unit]",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "write_service",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def write_service(base: Path, venv: Path, env_path: Path):\n    service = textwrap.dedent(\n        f\"\"\"\n        [Unit]\n        Description=tblock.fk watcher\n        After=network.target\n        [Service]\n        Type=simple\n        WorkingDirectory={base}\n        EnvironmentFile={env_path}",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "write_panel_service",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def write_panel_service(base: Path, venv: Path, env_path: Path, port: str):\n    service = textwrap.dedent(\n        f\"\"\"\n        [Unit]\n        Description=tblock.fk panel\n        After=network.target\n        [Service]\n        Type=simple\n        WorkingDirectory={base}\n        EnvironmentFile={env_path}",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "install_service_unit",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def install_service_unit(service_path: Path):\n    target = Path(\"/etc/systemd/system\") / service_path.name\n    cmds = [\n        ([\"cp\", str(service_path), str(target)], \"copy service\"),\n        ([\"systemctl\", \"daemon-reload\"], \"daemon-reload\"),\n        ([\"systemctl\", \"enable\", \"--now\", \"tblock-watcher.service\"], \"enable/start service\"),\n    ]\n    for cmd, desc in cmds:\n        final = cmd if os.geteuid() == 0 else [\"sudo\"] + cmd\n        try:",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "create_cli_menu",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def create_cli_menu():\n    script = textwrap.dedent(\n        \"\"\"\\\n        #!/usr/bin/env bash\n        set -euo pipefail\n        svc=\"tblock-watcher.service\"\n        svc_panel=\"tblock-panel.service\"\n        RED=\"\\\\033[91m\"; GREEN=\"\\\\033[92m\"; YELLOW=\"\\\\033[93m\"; CYAN=\"\\\\033[96m\"; RESET=\"\\\\033[0m\"; BOLD=\"\\\\033[1m\"\n        banner() {\n          cat <<'EOF'",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "def main():\n    base = TARGET_DIR\n    TARGET_DIR.mkdir(parents=True, exist_ok=True)\n    src_root = Path(__file__).resolve().parent\n    # sync files to TARGET_DIR\n    for name in [\"installer.py\", \"requirements.txt\", \"env.template\"]:\n        src = src_root / name\n        if src.exists():\n            (TARGET_DIR / name).write_bytes(src.read_bytes())\n    dst_dir = TARGET_DIR / \"pTblock\"",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "REQUESTS",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "REQUESTS = None\nGREEN = \"\\033[92m\"\nRED = \"\\033[91m\"\nYELLOW = \"\\033[93m\"\nCYAN = \"\\033[96m\"\nBOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "GREEN = \"\\033[92m\"\nRED = \"\\033[91m\"\nYELLOW = \"\\033[93m\"\nCYAN = \"\\033[96m\"\nBOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "RED = \"\\033[91m\"\nYELLOW = \"\\033[93m\"\nCYAN = \"\\033[96m\"\nBOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "YELLOW",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "YELLOW = \"\\033[93m\"\nCYAN = \"\\033[96m\"\nBOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "CYAN = \"\\033[96m\"\nBOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "BOLD",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "BOLD = \"\\033[1m\"\nRESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "RESET",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "RESET = \"\\033[0m\"\nXUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           ",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "XUI_DB_PATH",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "XUI_DB_PATH = Path(\"/etc/x-ui/x-ui.db\")\nTARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           \n| | | |   | |          | |     / _| |    (_)         | |      | | |          ",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "TARGET_DIR",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "TARGET_DIR = Path(\"/etc/tblock\")\nVALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           \n| | | |   | |          | |     / _| |    (_)         | |      | | |          \n| |_| |__ | | ___   ___| | __ | |_| | __  _ _ __  ___| |_ __ _| | | ___ _ __ ",
        "detail": "installer",
        "documentation": {}
    },
    {
        "label": "VALIDATOR_URL",
        "kind": 5,
        "importPath": "installer",
        "description": "installer",
        "peekOfCode": "VALIDATOR_URL = \"https://whale-app-sdmtd.ondigitalocean.app\"\ndef fail(msg: str):\n    print(f\"{RED}[!] {msg}{RESET}\")\n    sys.exit(1)\ndef banner():\n    art = r\"\"\"\n _   _     _            _       __ _      _           _        _ _           \n| | | |   | |          | |     / _| |    (_)         | |      | | |          \n| |_| |__ | | ___   ___| | __ | |_| | __  _ _ __  ___| |_ __ _| | | ___ _ __ \n| __| '_ \\| |/ _ \\ / __| |/ / |  _| |/ / | | '_ \\/ __| __/ _` | | |/ _ \\ '__|",
        "detail": "installer",
        "documentation": {}
    }
]